== 概要

FMI(Functional Mock-up Interface)は、FMU(Functional Mock-up Unit)と
呼ばれる実行形式で実装されるインターフェースを定義したものです。
FMIの機能は、シミュレーション環境がFMUの1つまたは複数のインスタンスを作成し、
通常は他のモデルと一緒にシミュレーションを行う際に使用されます（コール）。
FMUは独自のソルバーを持つこともあれば（「コ・シミュレーションのためのFMI」第4章）、
シミュレーション環境に数値積分を要求することもあります（「モデル交換のためのFMI」第3章）。
このインターフェースの目的は、シミュレーション環境におけるFMUの呼び出しが合理的に
簡単であることである。
本ドキュメントでは、モデリング環境からFMUを生成する方法については規定していません。

[underline]#FMI for Model Exchange#インターフェースは、[underline]#微分方程式#、
[underline]#代数方程式#、[underline]#離散時間方程式#で記述される動的システムの
モデルに対するインターフェースを定義します。
このインターフェースは、さまざまな[underline]#シミュレーション環境#や[underline]#組み込み制御システム#において、
明示的または暗黙的な積分器、固定または可変のステップサイズで、
必要に応じてこれらの方程式を評価するためのインターフェースを提供します。
インターフェースは、大規模なモデルの記述を可能にするように設計されています。

[underline]#FMI for Co-Simulation#は、シミュレーションツールの結合（シミュレータ結合、ツール結合）と、
シミュレータがソルバーとともに[underline]#実行可能なコード#としてエクスポートしたサブシステムモデルの結合の
両方に対応するように設計されています。
その目的は、時間的に連続したサブシステム（微分代数方程式で記述されたモデルコンポーネント）、
または時間的に離散したサブシステム（差分方程式で記述されたモデルコンポーネント、
例えば離散コントローラ）からなる時間依存の連成システムの解を計算することです。
結合システムのブロック表現では、サブシステムは、（内部）状態変数 `x(t)` 
を持つブロックで表され、サブシステム入力 `u(t)` とサブシステム出力 `y(t)` 
によって結合問題の他のサブシステム（ブロック）に接続されます。

ツールカップリングの場合、連成問題のモジュール構造は、シミュレーションプロセスのすべての段階で
利用されます。まず、個々のサブシステムについて、異なるシミュレーションツールで個別にモデルを
設定し、前処理を行います。
時間統合の際には、シミュレーションはすべてのサブシステムで独立して実行され、
サブシステム間のデータ交換は離散的な_通信ポイント_に制限されます。
最後に、シミュレーションデータの視覚化と後処理は、各サブシステムごとに、
それぞれのネイティブシミュレーションツールで行います。

この2つのインターフェースには共通する大きな部分があります。
これらの部分は第2章で定義されています。
特に、以下の点です。

- [underline]#FMI Application Programming Interface \(C)# +
All required equations or tool coupling computations are evaluated by calling standardized [underline]#C functions#.
C is used
because it is the most portable programming language today and is the only
programming language that can be utilized in all embedded control systems.

- [underline]#FMI Application Programming Interface \(C)# +
標準化されたC言語の関数を呼び出すことで、必要な方程式やツールカップリングの計算を行うことが
できます。C言語は、現在最もポータブルなプログラミング言語であり、すべての組み込み制御システム
で使用できる唯一のプログラミング言語であるため、使用されています。

- [underline]#FMI Description Schema (XML)# +
このスキーマは、モデリング環境によって生成されるXMLファイルの構造と内容を定義するものです。
このXMLファイルには、FMUのすべての変数の定義が標準化された方法で含まれています。
これにより、変数定義のオーバーヘッドなしに、組み込みシステムでCコードを実行することができます
（この情報をCコードに格納し、関数呼び出しでアクセスするという方法もありますが、
組み込みシステムや大規模なモデルでは実用的ではありません）。
さらに、変数定義は複雑なデータ構造であり、このデータ構造をどのようにプログラムで表現するかは、
ツールが自由に決定できるべきです。
ここでは、C++、C#、Java、Python などのシミュレーション環境のプログラミング言語で、
ツールが変数定義を（標準化されたアクセス関数によるメモリや効率のオーバーヘッドなしに）保存し、
アクセスできるようにするアプローチを採用しています。
なお、XMLファイルを適切なデータ構造に読み込むためのフリーおよび商用のライブラリが、
さまざまなプログラミング言語で多数提供されています。
例えば、http://en.wikipedia.org/wiki/XML#Parsers、特に効率的なオープンソースの
パーサーであるSAXを参照してください（http://sax.sourceforge.net/, 
http://en.wikipedia.org/wiki/Simple_API_for_XML）。

FMU (言い換えれば、インテグレータなしのモデル、インテグレータ付きの実行可能なモデル、
またはツール・カップリング・インターフェース)は、1つのZIPファイルで配布されます。
ZIPファイルの内容は以下の通りです（詳細は2.3項に記載）。

- FMI記述ファイル（XML形式）
- FMUのCソース（モデルで使用される必要なランタイムライブラリを含む）、
およびWindowsのダイナミックリンクライブラリ（.dll）やLinuxのシェアードオブジェクトライブラリ
（.so）など、1つまたは複数のターゲットマシン用のバイナリーです。
後者のソリューションは、FMUプロバイダが、含まれるノウハウを保護するためにソースコードを
隠したい場合や、別のシミュレーション環境にFMUを完全に自動的にインポートできるようにしたい
場合に特に使用されます。
FMUには物理的なパラメータや幾何学的な寸法が含まれている場合がありますが、
これらはオープンにすべきではありません。一方で、一部の機能はソースコードを必要とします。
- FMU固有のファイル形式による追加のFMUデータ（表や地図など）

FMUの概略図を図1に示します。

.環境とFMUの間のデータの流れ。
詳しくは第3章、第4章をご覧ください。
[blue]#青い#矢印：FMUが提供する情報です。
[red]#赤い#矢印：FMUに提供される情報です。
[caption="図 1: "]
image::images/enclosing_model.svg[width=60%, align="center"]

FMIに関する出版物は、https://fmi-standard.org/literature/, 特にBlochwitz他によるものは
http://www.ep.liu.se/ecp/063/013/ecp11063013.pdf[2011]や
http://www.ep.liu.se/ecp/076/017/ecp12076017.pdf[2012]から入手できます。

=== 特性と指針となる考え方

このセクションでは、プロパティをリストアップし、FMIの低レベル設計の指針となるいくつかの原則を
定義しています。
これにより、インターフェース機能の自己整合性を高めることができます。
リストアップされた問題は、高レベルのプロパティから低レベルの実装問題へとソートされています。

[role=indented]
_表現性_:
FMIは、Modelica(R)、Simulink(R)、SIMPACK(R) 
footnote:[ModelicaはModelica Associationの登録商標であり、Simulinkは
MathWorks Inc. はMathWorks Inc.の登録商標、SIMPACKはSIMPACK AGの登録商標です。]
のモデルがFMUに変換するために必要な機能を提供します。

[role=indented]
_安定性_: FMIは、世界中の多くのシミュレーションツールでサポートされることが期待されています。
このようなサポートを実装することは ツールベンダーにとって大きな投資となります。
そのため、FMIの安定性と後方互換性 の安定性と後方互換性は高い優先度を持っています。
これをサポートするために、FMIでは「ケイパビリティフラグ」を定義しています。
FMIの将来のバージョンで使用される「ケイパビリティフラグ」を定義しています。
このフラグは、将来のバージョンのFMIで使用されます。

[role=indented]
_実装_:
FMUは、手動で記述することも、モデリング環境から自動的に生成することもできる。
既存の手動でコード化されたモデルを、FMI規格に準拠したモデルに手動で変換することができます。

[role=indented]
_プロセッサの独立性_: ターゲットとなるプロセッサを知らなくても、FMUを配布することができます。
これにより、FMUをPC上で動作させることができます。Hardware-in-the-Loopシミュレーションプラットフォームや、
ECUのコントローラソフトウェアの一部として動作させることができます。
例えば、AUTOSAR SWCの一部として動作させることができます。
FMUをターゲットプロセッサから独立させることで、FMUの使い勝手が向上し、
AUTOSARのソフトウェアコンポーネントモデルでも要求されています。
実装:テキスト形式のFMUを使用する（FMUのC言語ソースを配布）。

[role=indented]
_シミュレータの独立性_: 
ターゲットとなるシミュレータを知らなくても、FMUをコンパイル、リンク、配布することができます。
理由:コンパイル時にFMUの使用を不必要に制限したり、ユーザーがFMUのシミュレータ固有の
バリエーションを維持することを強いることになるからである。

実装:バイナリFMUを使用します。Windowsのダイナミックリンクライブラリ（.dll）や
Linuxのシェアードオブジェクトライブラリ（.so）などのバイナリFMUを生成する際には、
ターゲットとなるオペレーティングシステム、そして最終的にはターゲットとなるプロセッサを知る
必要があります。
しかし、バイナリFMUの生成には、ターゲット・シミュレータのランタイム・ライブラリ、
ソース・ファイル、ヘッダ・ファイルは必要ありません。
その結果、バイナリFMUは、ターゲット・プラットフォーム上で動作するどのようなシミュレータでも
実行することができます（ただし、モデルや使用するランタイム・ライブラリから必要なライセンスが
提供されている場合に限ります）。

[role=indented]
_ランタイムオーバーヘッドが小さい_:
FMUとターゲット・シミュレータの間でFMIを介して通信を行う場合、ランタイム・オーバーヘッドが
大きくなることはありません。これは、新しいキャッシング技術（同じ変数を何度も計算することを
避けるため）と、スカラー量の代わりにベクトルを交換することによって実現されています。

[role=indented]
_Small footprint_: A compiled FMU (the executable) is small.
Reason: An FMU may run on an ECU (Electronic Control Unit,
for example, a microprocessor),
and ECUs have strong memory limitations.
This is achieved by storing signal attributes
(names, units, etc.)
and all other static information not needed for model evaluation in a separate text file
(= Model Description File)
that is not needed on the microprocessor where the executable might run.

[role=indented]
_Hide data structure_:
The FMI for Model Exchange does not prescribe a data structure (a C struct) to represent a model.
Reason: the FMI standard shall not unnecessarily restrict or prescribe a
certain implementation of FMUs or simulators (whichever contains the model data)
to ease implementation by different tool vendors.

[role=indented]
_Support many and nested FMUs_:
A simulator may run many FMUs in a single simulation run and/or multiple instances of one FMU.
The inputs and outputs of these FMUs can be connected with
direct feedthrough.
Moreover, an FMU may contain nested FMUs.

[role=indented]
_Numerical Robustness_:
The FMI standard allows that problems which are numerically critical
(for example, time and state events, multiple sample rates, stiff problems)
can be treated in a robust way.

[role=indented]
_Hide cache_:
A typical FMU will cache computed results for later reuse.
To simplify usage and to reduce error possibilities by a simulator,
the caching mechanism is hidden from the usage of the FMU.
Reason: First, the FMI should not force an FMU to implement a certain caching policy.
Second, this helps to keep the FMI simple.
Implementation:
The FMI provides explicit methods
(called by the FMU environment)
for setting properties that invalidate cached data.
An FMU that chooses to implement a cache may maintain a set of "dirty" flags,
hidden from the simulator.
A get method,
for example to a state, will then either trigger a computation, or return cached data,
depending on the value of these flags.

[role=indented]
_Support numerical solvers_:
A typical target simulator will use numerical solvers.
These solvers require vectors for states,
derivatives and zero-crossing functions.
The FMU directly fills the values of such vectors provided by the solvers.
Reason: minimize execution time.
The exposure of these vectors conflicts somewhat with the "hide data structure" requirement,
but the efficiency gain justifies this.

[role=indented]
_Explicit signature_:
The intended operations, argument types and return values are made explicit in the signature.
For example, an operator (such as `compute_derivatives`) is not passed as an int
argument but a special function is called for this.
The `const` prefix is used for any pointer that should not be changed,
including `const char*` instead of `char*`.
Reason: the correct use of the FMI can be checked at compile time
and allows calling of the C code in a C++ environment
(which is much stricter on `const` than C is).
This will help to develop FMUs that use the FMI in the intended way.

[role=indented]
_Few functions_:
The FMI consists of a few,
"orthogonal" functions,
avoiding redundant functions that could be defined in terms of others.
Reason: This leads to a compact, easy-to-use,
and hence attractive API with a compact documentation.

[role=indented]
_Error handling_:
All FMI methods use a common set of methods to communicate errors.

[role=indented]
_Allocator must free_:
All memory (and other resources) allocated by the FMU are freed (released) by the FMU.
Likewise, resources allocated by the simulator are released by the simulator.
Reason: this helps to prevent memory leaks and run-time errors due
to incompatible run-time environments for different components.

[role=indented]
_Immutable strings_:
All strings passed as arguments or returned are read-only
and must not be modified by the receiver.
Reason: This eases the reuse of strings.

[role=indented]
_Named list elements_:
All lists defined in the `fmiModelDescription.xsd` XML schema file have a String
attribute `name` to a list element.
This attribute must be unique with respect to all other `name`
attributes of the _same_ list.

[role=indented]
_Use C_:
The FMI is encoded using C, not C++.
Reason: Avoid problems with compiler and linker dependent behavior.
Run FMU on embedded target.

This version of the functional mock-up interface does
[underline]#not# have the following desirable properties.
They might be added in a future version.

- The FMI for Model Exchange is for ordinary differential equations (ODEs) in state space form.
It is not for a general differential-algebraic equation system.
However, algebraic equation systems inside the FMU are supported
(for example, the FMU can report to the environment to re-run the current step
with a smaller step size since a solution could not be found for an algebraic equation system).

- Special features that might be useful for multibody system programs,
like SIMPACK, are not included.

- The interface is for simulation and for embedded systems.
Properties that might be additionally
needed for trajectory optimization,
for example, derivatives of the model with respect to parameters
during continuous integration are not included.

- No explicit definition of the variable hierarchy in the XML file.

- The number of states and number of event indicators are fixed for an FMU and cannot be changed.

=== Acknowledgements

Until Dec. 2011, this work was carried out within the ITEA2 MODELISAR project (project number: ITEA2-07006, https://itea3.org/project/modelisar.html).

Daimler AG, DLR, ITI GmbH, Martin Luther University Halle-Wittenberg, QTronic GmbH and SIMPACK AG thank BMBF for partial funding of this work within MODELISAR (BMBF Förderkennzeichen: 01lS0800x).

Dassault Systèmes (Sweden) thanks the Swedish funding agency VINNOVA (2008-02291) for partial funding of this work within MODELISAR.

LMS Imagine and IFPEN thank DGCIS for partial funding of this work within MODELISAR.

Since Sept. 2012 until Nov. 2015, this work is partially carried out within the ITEA2 MODRIO project (project number: ITEA 2-11004, https://itea3.org/project/modrio.html).

- DLR, ITI GmbH, QTronic GmbH and SIMPACK AG thank BMBF for partial funding of this work within MODRIO (BMBF Förderkennzeichen: 01IS12022E).
- Dassault Systèmes (Sweden), Linköping University and Modelon AB thank the Swedish funding agency VINNOVA (2012--01157) for partial funding of this work within MODRIO.
- Siemens PLM Software (France) and IFPEN thank DGCIS for partial funding of this work within MODRIO.

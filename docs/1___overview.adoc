== 概要

FMI(Functional Mock-up Interface)は、FMU(Functional Mock-up Unit)と呼ばれる実行形式で実装されるインターフェースを定義したものです。
FMIの機能は、シミュレーション環境がFMUの1つまたは複数のインスタンスを作成し、通常は他のモデルと一緒にシミュレーションを行う際に使用されます（コール）。
FMUは独自のソルバーを持つこともあれば（「コ・シミュレーションのためのFMI」第4章）、シミュレーション環境に数値積分を要求することもあります（「モデル交換のためのFMI」第3章）。
このインターフェースの目的は、シミュレーション環境におけるFMUの呼び出しが合理的に簡単であることです。
本ドキュメントでは、モデリング環境からFMUを生成する方法については規定していません。

 [underline]#FMI for Model Exchange#インターフェースは、[underline]#微分方程式#、[underline]#代数方程式#、[underline]#離散時間方程式#で記述される動的システムのモデルに対するインターフェースを定義します。
このインターフェースは、さまざまな[underline]#シミュレーション環境#や[underline]#組み込み制御システム#において、明示的または暗黙的な積分器、固定または可変のステップサイズで、必要に応じてこれらの方程式を評価するためのインターフェースを提供します。
インターフェースは、大規模なモデルの記述を可能にするように設計されています。

 [underline]#FMI for Co-Simulation#は、シミュレーションツールの結合（シミュレータ結合、ツール結合）と、シミュレータがソルバーとともに[underline]#実行可能なコード#としてエクスポートしたサブシステムモデルの結合の両方に対応するように設計されています。
その目的は、時間的に連続したサブシステム（微分代数方程式で記述されたモデルコンポーネント）、または時間的に離散したサブシステム（差分方程式で記述されたモデルコンポーネント、例えば離散コントローラ）からなる時間依存の連成システムの解を計算することです。
結合システムのブロック表現では、サブシステムは、（内部）状態変数 `x(t)`を持つブロックで表され、サブシステム入力`u(t)`とサブシステム出力 `y(t)`によって結合問題の他のサブシステム（ブロック）に接続されます。

ツールカップリングの場合、連成問題のモジュール構造は、シミュレーションプロセスのすべての段階で利用されます。まず、個々のサブシステムについて、異なるシミュレーションツールで個別にモデルを設定し、前処理を行います。
時間統合の際には、シミュレーションはすべてのサブシステムで独立して実行され、サブシステム間のデータ交換は離散的な_通信ポイント_に制限されます。
最後に、シミュレーションデータの視覚化と後処理は、各サブシステムごとに、それぞれのネイティブシミュレーションツールで行います。

この2つのインターフェースには共通する大きな部分があります。
これらの部分は第2章で定義されています。
特に、以下の点です。

- [underline]#FMIアプリケーションプログラミングインターフェース（C）# +
すべての必要な方程式やツールカップリング計算は、標準化された[underline]#C関数#を呼び出して評価されます。
C言語は、現在最もポータブルなプログラミング言語であり、すべての組み込み制御システムで使用できる唯一のプログラミング言語であるため、C言語を使用しています。

- [underline]#FMI記述スキーマ(XML)# +
このスキーマは、モデリング環境によって生成されるXMLファイルの構造と内容を定義するものです。
このXMLファイルには、FMUのすべての変数の定義が標準化された方法で含まれています。
これにより、変数定義のオーバーヘッドなしに、組み込みシステムでCコードを実行することができます（この情報をCコードに格納し、関数呼び出しでアクセスするという方法もありますが、組み込みシステムや大規模なモデルでは実用的ではありません）。
さらに、変数定義は複雑なデータ構造であり、このデータ構造をどのようにプログラムで表現するかは、ツールが自由に決定できるべきです。
ここでは、C++、C#、Java、Python などのシミュレーション環境のプログラミング言語で、ツールが変数定義を（標準化されたアクセス関数によるメモリや効率のオーバーヘッドなしに）保存し、アクセスできるようにするアプローチを採用しています。
なお、XMLファイルを適切なデータ構造に読み込むためのフリーおよび商用のライブラリが、さまざまなプログラミング言語で多数提供されています。
例えば、http://en.wikipedia.org/wiki/XML#Parsers、特に効率的なオープンソースのパーサーであるSAXを参照してください（http://sax.sourceforge.net/, http://en.wikipedia.org/wiki/Simple_API_for_XML）。

FMU (言い換えれば、インテグレータなしのモデル、インテグレータ付きの実行可能なモデル、またはツール・カップリング・インターフェース)は、1つのZIPファイルで配布されます。
ZIPファイルの内容は以下の通りです（詳細は2.3項に記載）。

- FMI記述ファイル（XML形式）
- FMUのCソース（モデルで使用される必要なランタイムライブラリを含む）、およびWindowsのダイナミックリンクライブラリ（.dll）やLinuxのシェアードオブジェクトライブラリ（.so）など、1つまたは複数のターゲットマシン用のバイナリーです。
後者のソリューションは、FMUプロバイダが、含まれるノウハウを保護するためにソースコードを隠したい場合や、別のシミュレーション環境にFMUを完全に自動的にインポートできるようにしたい場合に特に使用されます。
FMUには物理的なパラメータや幾何学的な寸法が含まれている場合がありますが、これらはオープンにすべきではありません。一方で、一部の機能はソースコードを必要とします。
- FMU固有のファイル形式による追加のFMUデータ（表や地図など）

FMUの概略図を図1に示します。

.環境とFMUの間のデータの流れ。
詳しくは第3章、第4章をご覧ください。
[blue]#青い#矢印：FMUが提供する情報です。
[red]#赤い#矢印：FMUに提供される情報です。
[caption="図 1: "]
image::images/enclosing_model.svg[width=60%, align="center"]

FMIに関する出版物は、https://fmi-standard.org/literature/, 特にBlochwitz他によるものはhttp://www.ep.liu.se/ecp/063/013/ecp11063013.pdf[2011]やhttp://www.ep.liu.se/ecp/076/017/ecp12076017.pdf[2012]から入手できます。

=== 特性と指針となる考え方

このセクションでは、プロパティをリストアップし、FMIの低レベル設計の指針となるいくつかの原則を定義しています。
これにより、インターフェース機能の自己整合性を高めることができます。
リストアップされた問題は、高レベルのプロパティから低レベルの実装問題へとソートされています。

[role=indented]
_表現性_:
FMIは、Modelica(R)、Simulink(R)、SIMPACK(R) footnote:[ModelicaはModelica Associationの登録商標であり、SimulinkはMathWorks Inc. はMathWorks Inc.の登録商標、SIMPACKはSIMPACK AGの登録商標です。]のモデルがFMUに変換するために必要な機能を提供します。

[role=indented]
_安定性_: FMIは、世界中の多くのシミュレーションツールでサポートされることが期待されています。
このようなサポートを実装することは ツールベンダーにとって大きな投資となります。
そのため、FMIの安定性と後方互換性 の安定性と後方互換性は高い優先度を持っています。
これをサポートするために、FMIでは「ケイパビリティフラグ(capability flags)」を定義しています。
FMIの将来のバージョンで使用される「ケイパビリティフラグ(capability flags)」を定義しています。
このフラグは、将来のバージョンのFMIで使用されます。

[role=indented]
_実装_:
FMUは、手動で記述することも、モデリング環境から自動的に生成することもできます。
既存の手動でコード化されたモデルを、FMI規格に準拠したモデルに手動で変換することができます。

[role=indented]
_プロセッサの独立性_: 
ターゲットとなるプロセッサを知らなくても、FMUを配布することができます。
これにより、FMUをPC上で動作させることができます。Hardware-in-the-Loopシミュレーションプラットフォームや、ECUのコントローラソフトウェアの一部として動作させることができます。
例えば、AUTOSAR SWCの一部として動作させることができます。
FMUをターゲットプロセッサから独立させることで、FMUの使い勝手が向上し、AUTOSARのソフトウェアコンポーネントモデルでも要求されています。
実装:テキスト形式のFMUを使用します（FMUのC言語ソースを配布）。

[role=indented]
_シミュレータの独立性_: 
ターゲットとなるシミュレータを知らなくても、FMUをコンパイル、リンク、配布することができます。
理由：コンパイル時にFMUの使用を不必要に制限したり、ユーザーがFMUのシミュレータ固有のバリエーションを維持することを強要するなど、そうでなければこの規格の魅力は大きく損なわれます。
実装：バイナリFMUの使用。
Windowsのダイナミックリンクライブラリ（.dll）やLinuxのシェアードオブジェクトライブラリ（.so）などのバイナリFMUを生成する際には、ターゲットとなるオペレーティングシステム、そして最終的にはターゲットとなるプロセッサを知る必要があります。
しかし、バイナリFMUの生成には、ターゲット・シミュレータのランタイム・ライブラリ、ソース・ファイル、ヘッダ・ファイルは必要ありません。
その結果、バイナリFMUは、ターゲット・プラットフォーム上で動作するどのようなシミュレータでも実行することができます（ただし、モデルや使用するランタイム・ライブラリから必要なライセンスが提供されている場合に限ります）。

[role=indented]
_小さいランタイムオーバーヘッド_:
FMUとターゲット・シミュレータの間でFMIを介して通信を行う場合、ランタイム・オーバーヘッドが大きくなることはありません。
これは、新しいキャッシング技術（同じ変数を何度も計算することを避けるため）と、スカラー量の代わりにベクトルを交換することによって実現されています。

[role=indented]
_小さいフットプリント_: 
コンパイルされたFMU（実行ファイル）は小さい。
理由：FMUは、ECU（Electronic Control Unit、マイクロプロセッサなど）上で動作する場合があり、ECUには強いメモリ制限があります。
そのため、信号の属性（名称、単位など）やモデル評価に必要のない静的な情報は、実行ファイルが動作する可能性のあるマイクロプロセッサ上では不要な別のテキストファイル（＝モデル記述ファイル）に格納することで実現しています。

[role=indented]
_データ構造の隠蔽_:
モデル交換のためのFMIでは、モデルを表現するためのデータ構造（C構造体）を規定していません。
理由：FMI規格は、異なるツールベンダーによる実装を容易にするために、FMUまたはシミュレータ（モデルデータを含むもの）の特定の実装を不必要に制限または規定していません。

[role=indented]
_多数のFMUとネストしたFMUをサポート_:
シミュレータでは、1回のシミュレーションで多くのFMUを実行したり、1つのFMUの複数のインスタンスを実行したりすることができます。
これらのFMUの入力と出力は、直接フィードスルーで接続することができます。
さらに、1つのFMUがネストしたFMUを含む場合もあります。

[role=indented]
_数値的なロバスト性_:
FMI規格では、数値的に重要な問題（時間や状態のイベント、複数のサンプルレート、硬い問題など）をロバストな方法で扱うことができます。

[role=indented]
_キャッシュの隠蔽_:
一般的なFMUでは、計算結果を後で再利用するためにキャッシュします。
使い方を簡単にするために、また、シミュレータによるエラーの可能性を減らすために、キャッシュメカニズムはFMUの使用からは隠されています。
理由は以下の通りです。
第一に、FMIはFMUに特定のキャッシングポリシーの実装を強制してはならないためです。
第二に、これはFMIをシンプルに保つのに役立ちます。
実装：FMI は、キャッシュデータを無効にするプロパティを設定するための明示的なメソッド（FMU 環境によって呼び出されます）を提供します。
キャッシュを実装することを選択したFMUは、シミュレータから隠された「ダーティ」フラグのセットを維持することができます。
状態を取得するメソッドなどは、これらのフラグの値に応じて、計算を起動するか、キャッシュされたデータを返すことになります。

[role=indented]
_数値ソルバーのサポート_:
一般的なターゲットシミュレーターでは、数値ソルバーを使用します。
これらのソルバーは、状態、導関数、ゼロクロス関数のためのベクトルを必要とします。
FMUは、ソルバーから提供されたそのようなベクトルの値を直接埋めます。理由：実行時間の短縮のためです。
これらのベクトルの公開は、”データ構造の隠蔽"という要件に多少抵触しますが、効率化により正当化されます。

[role=indented]
_明示的なシグネチャ_:
意図した操作、引数の型、戻り値はシグネチャで明示されます。
例えば，演算子（`compute_derivatives`など）をint型の引数として渡すのではなく、そのための特別な関数が呼ばれます．
また，`char*`ではなく`const char*`など，変更してはいけないポインタには`const`という接頭辞が使われます．
理由: FMIの正しい使用方法をコンパイル時にチェックすることができ（Cよりも`const`に厳しい）、C++環境でCコードを呼び出すことができます。
これにより、意図した方法でFMIを使用するFMUの開発が可能になります。

[role=indented]
_少ない機能_:
FMIは、いくつかの「直交する」機能で構成されており、他の機能で定義できるような冗長な機能を避けています。
理由は：これにより、コンパクトで使いやすく、魅力的なAPIとコンパクトなドキュメントを実現しています。

[role=indented]
_エラーハンドリング_:
すべてのFMIメソッドは、エラーを伝えるために共通のメソッドを使用しています。

[role=indented]
_アロケータはフリー_:
FMUによって割り当てられたメモリ（およびその他のリソース）は、FMUによって解放（リリース）されます。
同様に、シミュレータによって割り当てられたリソースは、シミュレータによって解放されます。
理由：異なるコンポーネントの実行環境に互換性がないことによるメモリリークやランタイムエラーを防ぐことができます。

[role=indented]
_イミュータブルな文字列_:
引数として渡された文字列や返された文字列はすべて読み取り専用であり、受信者が変更することはできません。
理由： 文字列の再利用を容易にするためです。

[role=indented]
_名前付きリスト要素_:
`fmiModelDescription.xsd`というXMLスキーマファイルで定義されているすべてのリストは、リスト要素にString属性の`name`を持ちます。
この属性は、同じリストの他のすべての `name` 属性に対して一意でなければなりません。

[role=indented]
_Cの使用_:
FMIはC++ではなくCでエンコードされています。
理由:コンパイラやリンカに依存する動作の問題を避けるためです。
組み込みターゲットでFMUを実行します。

This version of the functional mock-up interface does
[underline]#not# have the following desirable properties.
They might be added in a future version.

本バージョンの機能的モックアップ・インターフェースは、以下の望ましい特性を持って[underline]#いません#。
これらは将来のバージョンで追加されるかもしれません。

- The FMI for Model Exchange is for ordinary differential equations (ODEs) in state space form.
It is not for a general differential-algebraic equation system.
However, algebraic equation systems inside the FMU are supported
(for example, the FMU can report to the environment to re-run the current step
with a smaller step size since a solution could not be found for an algebraic equation system).

- Special features that might be useful for multibody system programs,
like SIMPACK, are not included.

- The interface is for simulation and for embedded systems.
Properties that might be additionally
needed for trajectory optimization,
for example, derivatives of the model with respect to parameters
during continuous integration are not included.

- No explicit definition of the variable hierarchy in the XML file.

- The number of states and number of event indicators are fixed for an FMU and cannot be changed.

=== Acknowledgements

Until Dec. 2011, this work was carried out within the ITEA2 MODELISAR project (project number: ITEA2-07006, https://itea3.org/project/modelisar.html).

Daimler AG, DLR, ITI GmbH, Martin Luther University Halle-Wittenberg, QTronic GmbH and SIMPACK AG thank BMBF for partial funding of this work within MODELISAR (BMBF Förderkennzeichen: 01lS0800x).

Dassault Systèmes (Sweden) thanks the Swedish funding agency VINNOVA (2008-02291) for partial funding of this work within MODELISAR.

LMS Imagine and IFPEN thank DGCIS for partial funding of this work within MODELISAR.

Since Sept. 2012 until Nov. 2015, this work is partially carried out within the ITEA2 MODRIO project (project number: ITEA 2-11004, https://itea3.org/project/modrio.html).

- DLR, ITI GmbH, QTronic GmbH and SIMPACK AG thank BMBF for partial funding of this work within MODRIO (BMBF Förderkennzeichen: 01IS12022E).
- Dassault Systèmes (Sweden), Linköping University and Modelon AB thank the Swedish funding agency VINNOVA (2012--01157) for partial funding of this work within MODRIO.
- Siemens PLM Software (France) and IFPEN thank DGCIS for partial funding of this work within MODRIO.

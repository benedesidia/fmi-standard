=== FMIアプリケーション・プログラミング・インターフェース

このセクションでは、CプログラムからFMUの機能を実行するための共通インターフェース定義を記載しています。

なお、FMUには以下のような一般的な性質があります。

- 1つのインスタンスのFMI関数は、スレッドセーフである必要はありません。 +
_[例えば、FMUの1つのインスタンスの機能が複数のスレッドからアクセスされる場合。FMUを使用するマルチスレッド環境では、3.2.3項および4.2.4項で定義された関数の呼び出しシーケンスが使用されることを保証する必要があります。
FMU自身は、これをサポートするサービスを実装していません。]_

- FMI 関数は、他のプロセス/スレッドに影響するグローバル設定を変更してはいけません。
FMI 関数は、呼び出されたプロセス／スレッドの設定（浮動小数点制御レジスタなど）を変更することができます。ただし、これらの変更は、関数を終了する前、またはコールバック関数が呼び出される前に復元されます。 +
_[この特性により、異なるFMUインスタンスの関数を任意の順序で安全に呼び出すことができます。
さらに、関数が異なるプロセス/スレッドで呼び出されていれば、並行して呼び出すことができます。
FMI関数がCPUの浮動小数点制御ワードなどを変更した場合、関数が戻る前に以前の値に戻す必要があります。
x86 CPUの場合、浮動小数点制御ワードはfldcw命令で設定されます。
これは、「浮動小数点のゼロ除算」などの追加例外のスイッチを入れるために使用できます。
FMUは一時的に浮動小数点制御ワードを変更し、内部的に浮動小数点例外の通知を受けることができますが、それぞれのFMI関数が戻る前にフラグを復元し、浮動小数点ステータス・ワードをクリアする必要があります。]_


==== ヘッダーファイルと関数名の命名

FMUのインターフェースを定義する3つのヘッダーファイルが用意されています。
すべてのヘッダーファイルでは、C言語の関数や型の定義はすべて「[underline]#fumi2#」という接頭辞で始まるという規則が使われています。

- `fmi2TypesPlatform.h` +
には、関数の入力引数と出力引数の型定義が含まれています。
このヘッダファイルは，FMUとターゲットとなるシミュレータの両方で使用する必要があります。
ターゲットとなるシミュレータでヘッダファイルの定義が異なる場合（例えば、`**typedef double** fmi2Real`の代わりに`**typedef float** fmi2Real`）、[underline]#ターゲットとなるシミュレータ#で使用されているヘッダファイルを用いて[underline]#FMU#を[underline]#再コンパイル#する必要があります。
モデルがコンパイルされたヘッダファイルのプラットフォームは、ターゲットのシミュレータで次のように照会できます。
fmi2GetTypesPlatform` (セクション 2.1.4 参照)。 +
_[このヘッダーファイルでの定義の例: +
 `**typedef double** fmi2Real;` +
 ]_

- `fmi2FunctionTypes.h` +
には、FMUのすべての関数プロトタイプの `**typedef**` 定義が含まれています。
FMUを動的にロードする際には、これらの定義を使って、関数ポインタをそれぞれの関数定義にタイプキャストすることができます。
_[このヘッダーファイルでの定義の例: +
 `**typedef** fmi2Status fmi2SetTimeTYPE(fmi2Component, fmi2Real);` +
 ]_

- `fmi2Functions.h` +
には，シミュレーション環境でアクセス可能なFMUの関数プロトタイプが含まれており，2章，3章，4章で定義されています。
このヘッダファイルには，`fmi2TypesPlatform.h`と`fmi2Function.h`が含まれています。
モデルがコンパイルされたときのヘッダーファイルのバージョン番号です。ターゲットのシミュレータでは、`fmi2GetVersion` (セクション2.1.4参照)で確認できます。
_[このヘッダーファイルでの定義の例_ footnote:[MicrosoftとCygwinのコンパイラではFMI2_Export` は `pass:[__]declspec(dllexport)` として定義され、Gnu-Compilers では `FMI2_Export` は `pass:[__]attribute__ ( ( visibility("default") ) )` として定義され、ダイナミックローディングのために名前をエクスポートします。
それ以外は空の定義となります。]: +
_`FMI2_Export fmi2SetTimeTYPE fmi2SetTime;` +
]_

目標は、FMUのテキスト表現とバイナリ表現の両方をサポートし、1つの実行ファイルに複数のFMUが同時に存在する可能性があることです（例えば、FMU AがFMU Bを使用する場合など）。
これを可能にするためには、異なるFMUの関数名が異なるか、関数ポインタを使用する必要があります。
最初のバリエーションをサポートするために、FMUの出荷方法に依存する関数プレフィックスを使用して実際の関数名を構築するマクロが `fmi2Functions.h` で提供されています。
_[これらのマクロは、サポートされているコンパイラやインポートツールのプラットフォームの要件に合わせて、`fmi2Functions.h`のターゲット固有のバージョンで異なる定義をすることができます。]_

FMUのCファイルは、先頭に<fmiModelDescription><ModelExchange>`または<fmiModelDescription><CoSimulation>`で定義された`modelIdentifier`属性としての`FMI2_FUNCTION_PREFIX`の`define`を、末尾に`pass:[_]`を含めなければなりません（3.3.1項および4.3.1項参照）。

この`define`には、`#include "fumi2Functions.h"`を直接記述する必要があります。

通常、FMUの機能は以下のように使用されます。

[source, C]
----
// FMU is shipped with C source code, or with static link library
#define FMI2_FUNCTION_PREFIX MyModel_
#include "fmi2Functions.h"
< usage of the FMU functions >
----

[source, C]
----
// FMU is shipped with DLL/SharedObject
#include "fmi2Functions.h"
< usage of the FMU functions >
----

fmi2GetReal`と定義されている関数は、マクロによって以下のように関数名に変更されます。

- FMUにC言語のソースコードやスタティックリンクライブラリが付属している場合は: +
構築された関数名は `MyModel_fmi2GetReal` です。
つまり，関数名の前にはモデルの識別子と`pass:[_]`が付けられています．
したがって，シミュレーション環境では，実際の関数呼び出しのためのコードを生成することで，関連する関数名を構築することができます．
スタティックリンクライブラリの場合、ライブラリ名はWindowsではMyModel.lib、LinuxではlibMyModel.aとなり、`modelIdentifier`属性がライブラリ名として使用されます。

- FMUにDLL/SharedObjectが同梱されている場合: +
構築された関数名は `fmi2GetReal` であり、変更されていません。
_[これは、ソースコードのFMUが、関数名の構築にFMI2_FUNCTION_PREFIXを使用しないターゲット固有のバージョンの`fmi2Functions.h`を持つ場合に実現できます。]_
シミュレーション環境は、このライブラリを動的にロードし、FMI関数名を文字列として提供することで、関数シンボルを明示的にインポートします。
ライブラリの名前は、Windowsでは`MyModel.dll`、Linuxでは`MyModel.so`となり、つまり、`modelIdentifier`属性がライブラリ名として使われます。

_[FMUは、基本的に他のツールとの通信のみを含むように、オプションで出荷することができます（needsExecutionTool = true、4.3.1項参照）。
これは、特に共同シミュレーションタスクでよく見られます。
FMI 1.0では、関数名の前に常にモデル名が付いているため、モデルごとにDLL/共有オブジェクトを生成する必要があります。
FMI 2.0では、DLL/共有オブジェクトの場合、モデル名がプレフィックスとして使用されなくなったため、この状況が改善されました。
したがって、ツールカップリングの場合、1つのDLL/共有オブジェクトをすべてのモデルに使用することができます。
FMUがシミュレーション環境にインポートされる場合、これは通常、動的に実行され（FMU名に基づいて、シミュレーション環境の実行中に対応するFMUがロードされます）、モデル名がプレフィックスであるかどうかは問題ではありません。
]_

`modelIdentifier`は、C関数名のプレフィックスとして使用されるので、C関数名の制限を満たさなければなりません（文字、数字、アンダースコアのみが使用可能）。
_[例えば、`modelName = "A.B.C"`であれば、`modelIdentifier`は "A_B_C "となります。]_
modelIdentifier`は、ファイルシステムの名前としても使われます。ファイルシステムの名前としても使われるので、対象となるOSの制限を満たす必要があります。
基本的に、これは短くなければならないことを意味します。
例えば、WindowsのAPIでは、ファイルのフルパス名を260文字までしかサポートしていません。文字までしかサポートしていません（参照：http://msdn.microsoft.com/en-us/library/aa365247%28VS.85%29.aspx）。


==== プラットフォームに依存する定義 (fmi2TypesPlatform.h)

移植を容易にするため、関数のインターフェースにはC言語の型は使用していません。
しかし，このセクションではエイリアス型が定義されています。
このセクションのすべての定義は，ヘッダファイル `fmi2TypesPlatform.h` で提供されています。

`#define fmi2TypesPlatform "default"`

fmi2GetTypesPlatform`で問い合わせることができる定義です。
バイナリのコンパイルに使用するヘッダファイルを一意に識別するために使用されます。
_[以下の「デフォルト」定義は、ほとんどの一般的なプラットフォームに適しています。
すべてのバイナリFMUにこの「デフォルト」定義を使用することをお勧めします。
ソースコードFMUに限っては、場合によっては変更が有効なことがあります。]_:

----
fmi2Component           : 不透明なオブジェクトポインタ
fmi2ComponentEnvironment: 不透明なオブジェクトポインタ
fmi2FMUstate            : 不透明なオブジェクトポインタ
fmi2ValueReference      : 値のハンドル型
fmi2Real                : リアルデータ型
fmi2Integer             : 整数データ型
fmi2Boolean             : fmi2Trueおよびfmi2Falseで使用されるデータ型
fmi2Char                : 文字データ型（1文字の大きさ）
fmi2String              : fmi2Char文字のベクトルへのポインタ
                          (UTF-8エンコードのヌル終端文字列'\0')
fmi2Byte                : マシンの最小アドレス単位
                          (通常1バイト)
----

[source, C]
----
typedef void* fmi2Component;
----

これは、モデルの方程式を処理したり、それぞれのスレーブのコ・シミュレーションを処理するために必要な情報を含むFMU固有のデータ構造へのポインタです。
このデータ構造は、FMUを提供する環境によって実装されます。
言い換えれば、呼び出した環境はその内容を知らず、それを処理するコードはFMU生成環境が提供し、FMUと共に出荷されなければならないということです。

[source, C]
----
typedef void* fmi2ComponentEnvironment;
----

これは，FMUを呼び出すシミュレーション環境のデータ構造へのポインタです．
このポインタを使って，`modelDescription.xml`ファイルのデータ_[例えば、`valueReference`pass:[s]の変数名へのマッピング。]_をシミュレーション環境と`logger`関数（2.1.5項参照）の間で転送することができます．

[source, C]
----
typedef void* fmi2FMUstate;
----

FMUの内部状態を保存するデータ構造へのポインタで、実際の時間または前の時間の瞬間のFMUの内部状態を保存します。
これにより、前回のFMUの状態からシミュレーションを再開することができます（2.1.8項参照）。

[source, C]
----
typedef unsigned int fmi2ValueReference;
----

これは、モデルの(ベースタイプ)変数値へのハンドルです。
ハンドルとベースタイプ（`fmi2Real`など）は、変数の値を一意に識別します。
同じハンドルを持つ同じベースタイプの変数は、常に同一の値を持ちます。しかし、変数の定義の他の部分は異なる場合があります。 _[例えば、min/max属性]_.

レコードや配列などの構造化されたエンティティはすべて，`fmi2Real`や`fmi2Integer`などのスカラ値の集合に "フラット化 "されます．
fmi2ValueReference`はそのようなスカラの一つを参照します。
fmi2ValueReference`のコーディングは，FMUを生成した環境の "秘密 "です．
方程式のインターフェイスでは，このハンドルを介して変数にアクセスすることしかできません．
変数の具体的な情報を抽出するには、値のハンドルが定義されているモデル記述ファイルを読み込んだ使用環境に特有のものとなります。
以下のセクションの関数が間違った`fmi2ValueReference`の値で呼び出された場合は
_[例えば、`fmi2SetReal(...)`関数の呼び出しで定数を設定する場合などです]_,
その場合、この関数はエラー（`fmi2Status = fmi2Error`、セクション2.1.3参照）で返さなければなりません。

[source, C]
----
typedef double fmi2Real ; // Data type for floating point real numbers
typedef int fmi2Integer;  // Data type for signed integer numbers
typedef int fmi2Boolean;  // Data type for Boolean numbers
                          // (only two values: fmi2False, fmi2True)
typedef char fmi2Char;    // Data type for one character
typedef const fmi2Char* fmi2String; // Data type for character strings
                                    // ('\0' terminated, UTF8 encoded)
typedef char fmi2Byte;    // Data type for the smallest addressable
                          // unit, typically one byte
#define fmi2True 1
#define fmi2False 0
----

これらは、C関数のインターフェースで使用される基本的なデータ型です。
将来のバージョンのインターフェースでは、さらに多くのデータ型が追加される可能性があります。柔軟性を保つために，特に組み込みシステムや高性能コンピュータのために，正確なデータ型や数値のワード長は標準化されていません．
代わりに、正確な定義（言い換えれば、ヘッダファイル `fmi2TypesPlatform.h`）は、FMUが使用される環境によって提供されます。ほとんどの場合、上記の定義が使われます。
ターゲット環境の定義が異なり、FMUがバイナリ形式で配布されている場合は、このターゲットヘッダーファイルを用いて新たにコンパイルおよびリンクする必要があります。

fmi2String`変数がFMI関数の[underline]#input#引数として渡され、FMUがその文字列を後で使用する必要がある場合、FMI関数は関数が戻る前にその文字列をコピーし、FMUの内部メモリに保存しなければなりません。

FMI関数の[underline]#output#引数として`fmi2String`変数が渡され、その文字列がターゲット環境で使用される場合、ターゲット環境は（ポインタだけでなく）文字列全体をコピーする必要があります。
この文字列のメモリは、いずれかのFMIインターフェース関数の次の呼び出しによって解放される可能性があります。(文字列のメモリは、再利用される単なるバッファの場合もあります)。


==== 関数が返すステータス
このセクションでは、すべての関数が返す `status` フラグ (ファイル `fmi2FunctionTypes.h` で定義されている `fmi2Status` 型の列挙型) を定義します。ファイル`fmi2FunctionTypes.h`で定義されている`fmi2Status`型の列挙）を定義します。


[source, C]
----
typedef enum { fmi2OK,
               fmi2Warning,
               fmi2Discard,
               fmi2Error,
               fmi2Fatal,
               fmi2Pending } fmi2Status;
----

関数が返すステータス。
ステータスの意味は以下の通りです。

- `fmi2OK` - すべて順調

- `fmi2Warning` - 完全に正しくありませんが、計算は続行できます。
モデルの中では，関数`logger`が呼び出されており（下記参照），この関数が用意した情報メッセージをユーザに表示したことが予想されます。

- `fmi2Discard` - この戻り値は、対応する関数で明示的に定義されている場合のみ可能です footnote:[関数 `fmi2SetXXX` は通常、計算を行わず、渡された値を内部バッファに格納するだけです。
実際の計算は`fmi2GetXXX`関数が行います。
しかし、`fmi2SetXXX`関数は、入力された引数が有効範囲内にあるかどうかをチェックすることができます。
そうでない場合、これらの関数は `fmi2Discard` で返すことができます。]:
(ModelExchange: `fmi2SetReal`, `fmi2SetInteger`, `fmi2SetBoolean`, `fmi2SetString`,
`fmi2SetContinuousStates`, `fmi2GetReal`, `fmi2GetDerivatives`,
`fmi2GetContinuousStates`, `fmi2GetEventIndicators`;
CoSimulation: `fmi2SetReal`, `fmi2SetInteger`, `fmi2SetBoolean`, `fmi2SetString`, `fmi2DoStep`,
`fmiGetXXXStatus` ): +
「モデル交換」の場合：モデルの反復ソルバーが収束しなかった場合や、モデルの方程式を再度評価する場合など、ステップサイズを小さくして実行することが推奨されます。モデルの反復ソルバーが収束しなかった場合や、関数が領域外にある場合（例：`sqrt(<負の数>)`）などには 例えば、モデル内の反復ソルバーが収束しなかった場合や、関数がその領域外にある場合（例：`sqrt(<負の数>)`）などです。
これができない場合は、シミュレーションを終了しなければなりません。 +
「co-simulation」の場合：スレーブが必要なステータス情報を返せなかった場合も、`fmi2Discard`を返します。ステータス情報を返すことができない場合にも返されます。
マスターは、シミュレーションの実行を継続できるかどうかを判断する必要があります。 +
いずれの場合も、FMUでは関数`logger`が呼び出されており（下記参照）、FMUがデバッグモード（`loggingOn = fmi2True`）で呼び出された場合には、この関数が用意された情報メッセージをユーザーに表示していることが予想されます。
それ以外の場合は、`logger`はメッセージを表示してはいけません。

- `fmi2Error` - FMUにエラーが発生しました。
このFMUインスタンスでは、シミュレーションを続行できません。
いずれかの関数が `fmi2Error` を返した場合は、`fmi2SetFMUstate` を呼び出して、以前に保存した FMU の状態からシミュレーションを再開することができます。
これは、ケイパビリティフラグの `canGetAndSetFMUstate` が真であり、`fmi2GetFMUstate` が以前にエラーにならない状態で呼び出されていた場合に実行できます。
footnote:[通常、`fmi2Error`は「ディスクが一杯です」などの数字にならない理由で返されます。
fmi2SetFMUstate`で定義された最後の一貫した状態でシミュレーションを続行することができます。]。+
特に他のFMUインスタンスは影響を受けません。
FMUでは、関数`logger`が呼び出されており（下記参照）、この関数が用意された情報メッセージをユーザーに表示していることが予想されます。

- `fmi2Fatal` - すべての FMU インスタンスでモデル計算が修復不可能なほど破損します。
_[例えば、fmi関数の実行中に、アクセス違反や整数のゼロ除算などのランタイム例外が発生したため]_です。
FMUで関数`logger`が呼び出され（下記参照）、この関数が用意した情報メッセージをユーザーに表示したことが予想されます。
FMUのどのインスタンスに対しても、他の関数を呼び出すことはできません。

- `fmi2Pending` - このステータスは、スレーブが非同期で関数を実行した場合に、コ・シミュレーションのインターフェースからのみ返されます。
つまり，スレーブが計算を開始してもすぐに戻ってくるということです．
マスターはスレーブが計算を終了したかどうかを判断するために、`fmi2GetStatus(..., fmi2DoStepStatus)`を呼び出す必要があります。
fmi2DoStep`と`fmi2GetStatus`(4.2.3項参照)でのみ返すことができます。


==== ヘッダーファイルのプラットフォームとバージョン番号の照会

このセクションでは、関数のコンパイルに使用されたヘッダーファイルの情報を照会するために、関数を文書化します。

[source, C]
----
const char* fmi2GetTypesPlatform(void);
----

FMUの機能のコンパイルに用いられるヘッダファイル `fmi2TypesPlatform.h` を一意に識別するための文字列を返します。
この関数は，このヘッダファイルで定義されている `fmi2TypesPlatform` で指定される静的な文字列へのポインタを返します．
本仕様書に記載されている標準的なヘッダファイルでは，`fmi2TypesPlatform`が`default`に設定されています（したがって，この関数は通常`default`を返します）．

[source, C]
----
const char* fmi2GetVersion(void);
----

FMUの関数をコンパイルする際に使用したヘッダファイル `fmi2Functions.h` のバージョンを返します。
この関数は、このヘッダファイルで定義されている `fmiVersion` を返します。
本仕様書に記載されている標準的なヘッダファイルのバージョンは `"2.0"` です（したがって、この関数は通常 `"2.0"` を返します）。


==== FMUインスタンスの作成、破棄、ログの記録

ここでは、FMUのインスタンス化、破壊、ロギングに対応する機能について説明します。

[source, C]
----
fmi2Component fmi2Instantiate(fmi2String  instanceName,
                              fmi2Type    fmuType,
                              fmi2String fmuGUID,
                              fmi2String fmuResourceLocation,
                              const fmi2CallbackFunctions* functions,
                              fmi2Boolean visible,
                              fmi2Boolean loggingOn);
----

[source, C]
----
typedef enum {fmi2ModelExchange,
              fmi2CoSimulation
             }fmi2Type;
----

この関数は，FMU の新しいインスタンスを返します。
もし，NULLポインタが返された場合には，インスタンスの生成に失敗したことになります．
この場合，`functions->logger` が呼ばれ，その理由に関する詳細な情報が表示されます．
FMUは何度でもインスタンスを作成することができます（ケイパビリティフラグ`canBeInstantiatedOnlyOncePerProcess = false`があれば）。

以下の関数を呼び出す前に、この関数が正常に呼び出される必要があります。
共同シミュレーションの場合、この関数の呼び出しは、シミュレーションの実行を開始する前に必要なスレーブのすべてのアクションを実行する必要があります（たとえば、モデルファイルの読み込み、コンパイルなど）。

引数 `instanceName` は、FMUインスタンスの一意の識別子です。
これは、例えば、`fmi2XXX`関数のいずれかによって生成されたエラーまたは情報メッセージの中で、インスタンスの名前を付けるために使用されます。
また、この文字列は空であってはなりません（言い換えれば、少なくとも1つの文字が空白であってはなりません）。
_[1つのFMUのみをシミュレートする場合、instanceName属性として`modelName`またはXMLスキーマ`fmiModelDescription`の`<ModelExchange/CoSimulation modelIdentifier="...">`が使用されるかもしれません]_。

引数 `fmuType` は、FMUのタイプを定義します。:

- = `fmi2ModelExchange`: FMUの初期化とイベント;
連続したシステムのイベント間シミュレーションは、環境からの外部インテグレータを用いて 環境からの外部インテグレーターを用いて行われます（セクション3参照）。
- = `fmi2CoSimulation`: コ・シミュレーションのためのブラックボックス・インターフェース（セクション4参照）。

引数 `fmuGUID` は，`modelDescription.xml` ファイル（2.3節参照）がFMUのCコードと互換性があるかどうかを確認するために使用します．
これは、XMLファイルのベンダー固有のグローバルに一意な識別子です（例えば、XMLファイルに格納されている関連情報の「フィンガープリント」です）。
これは、XMLファイルの属性 "guid"（2.2.1項参照）として格納されており、`fmi2Instantiate`関数の引数`fmuGUID`に渡す必要があります。
これは，`fmi2Instantiate`関数の内部に格納されているものと同一でなければなりません．
さもなければ、C言語のコードとFMUのXMLファイルの整合性が取れません。
この引数はNULLではありません。

引数 `fmuResourceLocation` は、次の構文によるURIです。
http://datatracker.ietf.org/doc/rfc3986/[IETF RFC3986]の構文に従ったURIです。FMUアーカイブを解凍した際の`resources`ディレクトリへの位置を示すURIです。
以下のスキームは、FMUによって理解されなければなりません。:

- 必須項目です。"file "の絶対パス（オーソリティコンポーネントを含む、または含まない）。
- 任意："http"、"https"、"ftp"
- 予約済みです。FMI for PLM のための "fumi2" です。

_[例 FMUを "C:temp\MyFMU "というディレクトリに解凍した場合、fmuResourceLocation = "file:///C:/temp/MyFMU/resources "または "file:/C:/temp/MyFMU/resources "となります。
関数 `fmi2Instantiate` は、このディレクトリから、FMUが使用するマップやテーブルなど、必要なリソースをすべて読み込むことができます。]_

引数 `functions` は、環境からのリソースを利用するために、FMUの機能から使用するコールバック関数を提供します（下記のタイプ `fmi2CallbackFunctions` を参照）。

引数 `visible = fmi2False` は、ユーザーとのインタラクションを最小限に抑えることを定義しています（アプリケーションウィンドウがない、プロットがない、アニメーションがない、など）。
言い換えれば，FMUはバッチモードで実行されます．
Visible = fmi2True`の場合、FMUはインタラクティブモードで実行され、FMUはシミュレーション/インスタンス化/初期化の開始を明示的に確認する必要があるかもしれません（確認はノンブロッキングです）。

If `loggingOn = fmi2True`, デバッグログが有効になります。 +
If `loggingOn = fmi2False`, デバッグログが無効になります。

_[FMUは、この引数に従って、デバッグに役立つ`LogCategories`を有効／無効にします。
FMUがどの`LogCategories`を設定するかは未設定です。]_

[source, C]
----
typedef struct {
     void  (*logger)(fmi2ComponentEnvironment componentEnvironment,
                          fmi2String instanceName,
                          fmi2Status status,
                          fmi2String category,
                          fmi2String message, ...);
     void* (*allocateMemory)(size_t nobj, size_t size);
     void  (*freeMemory)    (void* obj);
     void (*stepFinished)   (fmi2ComponentEnvironment componentEnvironment,
                             fmi2Status status);
     fmi2ComponentEnvironment componentEnvironment;
} fmi2CallbackFunctions;
----

この構造体には、FMUが使用するために環境が提供する関数へのポインタが含まれています。
これらの関数を `fmi2Instantiate(...)` と `fmi2Terminate(...)` の間で変更することはできません。
さらに、`logger`関数が環境からのデータを利用できるように、`valueReference`を文字列にマッピングするなど、`logger`関数に渡す必要のある環境へのポインタ（componentEnvironment）が提供されます。
万が一、`fmi2Component`が`logger`でも必要になる場合は、引数componentEnvironment`を介して渡す必要があります。
引数 `componentEnvironment` には null ポインタを指定できます。

The `componentEnvironment` pointer is also passed to the `stepFinished(..)` function in order
that the environment can provide an efficient way to identify the slave that called `stepFinished(..)`.

In the default `fmi2FunctionTypes.h` file,
typedefs for the function definitions are present to simplify the usage;
this is non-normative.
The functions have the following meaning:

Function *logger*:
Pointer to a function that is called by the FMU _[usually if an `fmi2XXX` function does not behave as desired]_.
If `status = fmi2OK`, the message is a pure information message.
`instanceName` is the name of the FMU instance that calls this function.
`category` is the category of the message.

The allowed values for `category` are defined in the `modelDescription.xml` file via the element `<fmiModelDescription><LogCategories>`, see section 2.2.4.
`logger` should only be called for log categories that were enabled by a call to `fmi2SetDebugLogging` (see below) or via `loggingOn = fmi2True` in `fmi2Instantiate`.
If the FMU does not define any log categories, `category` must be `NULL`.
Argument `message` is a string that contains the message to log.
It may contain line-breaks (`\n`), but should not have a trailing line break and is provided in the same way and with the
same format control as in function `printf` from the C standard library. +
_[Typically, this function prints the message and stores it optionally in a log file.]_

All string-valued arguments passed by the FMU to the `logger` may be deallocated by the FMU directly after function `logger` returns.
_[The simulation environment must therefore create copies of these strings if it needs to access these strings later.]_ +

Variables are referenced in a message with `\#<Type><ValueReference>#` where <Type> is "r" for `fmi2Real`,
"i" for `fmi2Integer`, "b" for `fmi2Boolean` and "s" for `fmi2String`.
If character `pass:[#]` shall be included in the message,
it has to be prefixed with `pass:[#]`, so `#` is an escape character.
_[Example:_


_A message of the form "\#r1365#" must be larger than zero (used in IO channel ##4)"_ +
_might be changed by the `logger` function to_ +
_`"body.m must be larger than zero (used in IO channel #4)"`_ +
_if `"body.m"` is the name of the `fmi2Real` variable with `fmi2ValueReference = 1365`.]_

Function *allocateMemory*: +
Pointer to a function that is called in the FMU if memory needs to be allocated.
If attribute `canNotUseMemoryManagementFunctions = true` in `<fmiModelDescription><ModelExchange / CoSimulation>`,
then function `allocateMemory` is not used in the FMU and a void pointer can be provided.
If this attribute has a value of `false` (which is the default),
the FMU must not use `malloc`, `calloc` or other memory allocation functions.
One reason is that these functions might not be available for embedded systems on the target machine.
Another reason is that the environment may have optimized or specialized memory allocation functions.
`allocateMemory` returns a pointer to space for a vector of `nobj` objects,
each of size `size` or `NULL`, if the request cannot be satisfied.
The space is initialized to zero bytes _[(a simple implementation is to use `calloc` from the C standard library)]_.

Function *freeMemory*: +
Pointer to a function that must be called in the FMU if memory is freed that has been allocated with `allocateMemory`.
If a null pointer is provided as input argument `obj`,
the function shall perform no action _[(a simple implementation is to use free from the C standard library;
in ANSI C89 and C99, the null pointer handling is identical as defined here)]_.
If attribute `canNotUseMemoryManagementFunctions = true` in `<fmiModelDescription><ModelExchange / CoSimulation>`,
then function `freeMemory` is not used in the FMU and a null pointer can be provided.

Function *stepFinished*: +
Optional call back function to signal if the computation of a communication step of a co- simulation slave is finished.
A null pointer can be provided.
In this case the master must use `fmiGetStatus(..)` to query the status of `fmi2DoStep`.
If a pointer to a function is provided, it must be called by the FMU after a completed communication step.

_[Note: In FMI 3.0, memory callback functions were removed, because their intended uses failed to materialize and the implementations often had issues.
New in FMI 2.0.2: It is discouraged to use the memory callback functions.]_

[source, C]
----
void fmi2FreeInstance(fmi2Component c);
----

Disposes the given instance, unloads the loaded model,
and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface.
If a null pointer is provided for `c`, the function call is ignored (does not have an effect).


[source, C]
----
fmi2Status fmi2SetDebugLogging(fmi2Component c, fmi2Boolean loggingOn,
                               size_t nCategories,
                               const fmi2String categories[]);
----
The function controls the debug logging that is output via the logger callback function by the FMU.

If `loggingOn == fmi2True`, debug logging is enabled for the log categories specified in `categories`, otherwise it is disabled.
`nCategories` defines the length of the argument `categories`.
If `nCategories == 0`, `loggingOn` applies to all log categories and the value of categories is undefined.
The allowed values of `categories` are defined in the `modelDescription.xml` file via element `<LogCategories>`, see section 2.2.4.

==== Initialization, Termination, and Resetting an FMU

This section documents functions that deal with initialization, termination, and resetting of an FMU.

[source, C]
----
fmi2Status fmi2SetupExperiment(fmi2Component c,
                               fmi2Boolean   toleranceDefined,
                               fmi2Real      tolerance,
                               fmi2Real      startTime,
                               fmi2Boolean   stopTimeDefined,
                               fmi2Real      stopTime);
----

Informs the FMU to set up the experiment.
This function must be called after `fmi2Instantiate` and before `fmi2EnterInitializationMode` is called.
Arguments `toleranceDefined` and `tolerance` depend on the FMU type:

[role=second-indented]
*fmuType = fmi2ModelExchange*: +
If `toleranceDefined = fmi2True`, then the model is called with a numerical integration scheme where the
step size is controlled by using `tolerance` for error estimation (usually as relative 'tolerance').
In such a case all numerical algorithms used inside the model (for example, to solve non-linear algebraic
equations) should also operate with an error estimation of an appropriate smaller relative tolerance.

[role=second-indented]
*fmuType = fmi2CoSimulation*: +
If `toleranceDefined = fmi2True`, then the communication interval of the slave is controlled by error estimation.
In case the slave utilizes a numerical integrator with variable step size and error estimation,
it is suggested to use `tolerance` for the error estimation of the internal integrator
(usually as relative tolerance). +
An FMU for Co-Simulation might ignore this argument.

The arguments `startTime` and `stopTime` can be used to check whether the model is valid within
the given boundaries or to allocate memory which is necessary for storing results.
Argument `startTime` is the fixed initial value of the independent variable
footnote:[The variable that is defined with `causality = "independent"` in the `fmiModelDescription.xml` file.]
value _[if the independent variable is `time`, `startTime` is the starting time of initializaton]_.
If `stopTimeDefined = fmi2True`,
then `stopTime` is the defined final value of the independent variable [if the independent variable is `time`,
`stopTime` is the stop time of the simulation] and if the environment tries to compute past `stopTime` the FMU
has to return `fmi2Status = fmi2Error`.
 If `stopTimeDefined = fmi2False`,
 then no final value of the independent variable is defined and argument `stopTime` is meaningless.


[source, C]
----
fmi2Status fmi2EnterInitializationMode(fmi2Component c);
----

Informs the FMU to enter Initialization Mode.
Before calling this function,
all variables with attribute `<ScalarVariable initial = exact` or `approx>` can be set with
the `fmi2SetXXX` functions (the `ScalarVariable` attributes are defined in the Model Description File,
see section 2.2.7).
Setting other variables is not allowed.
Furthermore, `fmi2SetupExperiment` must be called at least once before calling `fmi2EnterInitializationMode`,
in order that `startTime` is defined.

[source, C]
----
fmi2Status fmi2ExitInitializationMode(fmi2Component c);
----

Informs the FMU to exit Initialization Mode.
For `fmuType = fmi2ModelExchange`,
this function switches off all initialization equations, and the FMU enters Event Mode implicitly;
that is, all continuous-time and active discrete-time equations are available.

[source, C]
----
fmi2Status fmi2Terminate(fmi2Component c);
----

Informs the FMU that the simulation run is terminated.
After calling this function,
the final values of all variables can be inquired with the `fmi2GetXXX(..)` functions.
It is not allowed to call this function after one of the functions returned with a status flag of `fmi2Error` or `fmi2Fatal`.

[source, C]
----
fmi2Status fmi2Reset(fmi2Component c);
----

Is called by the environment to reset the FMU after a simulation run.
The FMU goes into the same state as if `fmi2Instantiate` would have been called.
All variables have their default values.
Before starting a new run, `fmi2SetupExperiment` and `fmi2EnterInitializationMode` have to be called.

==== Getting and Setting Variable Values

All variable values of an FMU are identified with a variable handle called "value reference".
The handle is defined in the `modelDescription.xml` file (as attribute `valueReference` in element `ScalarVariable`).
Element `valueReference` might not be unique for all variables.
If two or more variables of the same base data type (such as `fmi2Real`) have the same `valueReference`,
then they have identical values but other parts of the variable definition might be different
_[for example, min/max attributes]_.

The actual values of the variables that are defined in the `modelDescription.xml`
file can be inquired after calling `fmi2EnterInitializationMode` with the following functions:

[source, C]
----
fmi2Status fmi2GetReal   (fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, fmi2Real value[]);
fmi2Status fmi2GetInteger(fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, fmi2Integer value[]);
fmi2Status fmi2GetBoolean(fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, fmi2Boolean value[]);
fmi2Status fmi2GetString (fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, fmi2String value[]);
----

[role=indented2]
Get actual values of variables by providing their variable references.
_[These functions are especially used to get the actual values of output variables if a model is connected with other models.
Since state derivatives are also `ScalarVariable`pass:[s],
it is possible to get the value of a state derivative.
This is useful when connecting FMUs together.
Furthermore, the actual value of every variable defined in the `modelDescription.xml` file
can be determined at the actually defined time instant (see section 2.2.7).]_

[role=indented2]
- Argument `vr` is a vector of `nvr` value handles that define the variables that shall be inquired.
- Argument `value` is a vector with the actual values of these variables.
- The strings returned by `fmi2GetString` must be copied in the target environment
because the allocated memory for these strings might be deallocated by the next call to
any of the fmi2 interface functions or it might be an internal string buffer that is reused.
- For ModelExchange: `fmi2Status = fmi2Discard` is possible for `fmi2GetReal` only,
but not for `fmi2GetInteger`, `fmi2GetBoolean`, `fmi2GetString`,
because these are discrete-time variables and their values can only change at
an event instant where `fmi2Discard` does not make sense.

It is also possible to [underline]#set# the values of [underline]#certain# variables at particular instants in time using the following functions:

[source, C]
----
fmi2Status fmi2SetReal   (fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, const fmi2Real value[]);
fmi2Status fmi2SetInteger(fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, const fmi2Integer value[]);
fmi2Status fmi2SetBoolean(fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, const fmi2Boolean value[]);
fmi2Status fmi2SetString (fmi2Component c, const fmi2ValueReference vr[],
                          size_t nvr, const fmi2String value[]);
----

[role=indented2]
Set parameters, inputs, and start values, and re-initialize caching of variables that depend on these variables
(see section 2.2.7 for the exact rules on which type of variables `fmi2SetXXX` can be called,
as well as section 3.2.3 in case of ModelExchange and section 4.2.4 in case of CoSimulation).

[role=indented2]
- Argument `vr` is a vector of `nvr` value handles that define the variables that shall be set.
- Argument `value` is a vector with the actual values of these variables.
- All strings passed as arguments to `fmi2SetString` must be copied inside this function,
because there is no guarantee of the lifetime of strings when this function returns.
- Note, `fmi2Status = fmi2Discard` is possible for the `fmi2SetXXX` functions.

For co-simulation FMUs,
additional functions are defined in section 4.2.1 to set and inquire derivatives of variables with respect
to time in order to allow interpolation.

[#GetSetCompleteFMUState]
==== Getting and Setting the Complete FMU State

The FMU has an internal state consisting of all values that are needed to continue a simulation.
This internal state consists especially of the values of the continuous-time states, iteration variables,
parameter values, input values, delay buffers, file identifiers, and FMU internal status information.
With the functions of this section,
the internal FMU state can be copied and the pointer to this copy is returned to the environment.
The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.

_[Examples for using this feature:_

_For variable step-size control of co-simulation master algorithms (get the FMU state for every accepted
communication step;
if the follow-up step is not accepted, restart co-simulation from this FMU state)._

_For nonlinear Kalman filters (get the FMU state just before initialization;
in every sample period, set new continuous states from the Kalman filter algorithm based on measured values;
integrate to the next sample instant and inquire the predicted continuous states that are used
in the Kalman filter algorithm as basis to set new continuous states)._

_For nonlinear model predictive control (get the FMU state just before initialization;
in every sample period, set new continuous states from an observer,
initialize and get the FMU state after initialization.
From this state, perform many simulations that are restarted after the initialization with new input signals proposed by the optimizer).]_

Furthermore, the FMU state can be serialized and copied in a byte vector:
_[This can be, for example, used to perform an expensive steady-state initialization,
copy the received FMU state in a byte vector and store this vector on file.
Whenever needed, the byte vector can be loaded from file
and deserialized, and the simulation can be restarted from this FMU state,
in other words, from the steady-state initialization.]_

[source, C]
----
fmi2Status fmi2GetFMUstate (fmi2Component c, fmi2FMUstate* FMUstate);
fmi2Status fmi2SetFMUstate (fmi2Component c, fmi2FMUstate  FMUstate);
fmi2Status fmi2FreeFMUstate(fmi2Component c, fmi2FMUstate* FMUstate);
----

`fmi2GetFMUstate` makes a copy of the internal FMU state and returns a pointer to this copy (`FMUstate`).
If on entry `*FMUstate == NULL`, a new allocation is required.
If `*FMUstate != NULL`, then `*FMUstate` points to a previously returned `FMUstate` that has not been modified since.
In particular, `fmi2FreeFMUstate` had not been called with this `FMUstate` as an argument.
_[Function `fmi2GetFMUstate` typically reuses the memory of this `FMUstate`
in this case and returns the same pointer to it, but with the actual `FMUstate`.]_

`fmi2SetFMUstate` copies the content of the previously copied `FMUstate` back and uses it as actual new FMU state.
The `FMUstate` copy still exists.

`fmi2FreeFMUstate` frees all memory and other resources allocated with the `fmi2GetFMUstate` call for this `FMUstate`.
The input argument to this function is the `FMUstate` to be freed.
If a null pointer is provided, the call is ignored.
The function returns a null pointer in argument `FMUstate`.

These functions are only supported by the FMU,
if the optional capability flag `canGetAndSetFMUstate` in `<fmiModelDescription> <ModelExchange / CoSimulation> `
in the XML file is explicitly set to `true` (see sections 3.3.1 and 4.3.1).

[source, C]
----
mi2Status fmi2SerializedFMUstateSize(fmi2Component c, fmi2FMUstate FMUstate,
                                     size_t *size);
fmi2Status fmi2SerializeFMUstate    (fmi2Component c, fmi2FMUstate FMUstate,
                                     fmi2Byte serializedState[], size_t size);
fmi2Status fmi2DeSerializeFMUstate  (fmi2Component c,
                                     const fmi2Byte serializedState[],
                                     size_t size, fmi2FMUstate* FMUstate);
----

`fmi2SerializedFMUstateSize` returns the `size` of the byte vector,
in order that `FMUstate` can be stored in it.
With this information, the environment has to allocate an `fmi2Byte` vector of the required length `size`.

`fmi2SerializeFMUstate` serializes the data which is referenced by pointer `FMUstate` and copies this
data in to the byte vector `serializedState` of length `size`, that must be provided by the environment.

`fmi2DeSerializeFMUstate` deserializes the byte vector `serializedState` of length `size`,
constructs a copy of the FMU state and returns `FMUstate`, the pointer to this copy.
_[The simulation is restarted at this state, when calling `fmi2SetFMUState` with `FMUstate`.]_

These functions are only supported by the FMU,
if the optional capability flags `canGetAndSetFMUstate` and `canSerializeFMUstate` in
`<fmiModelDescription><ModelExchange / CoSimulation>` in the XML file are explicitly set to `true` (see sections 3.3.1 and 4.3.1).

==== Getting Partial Derivatives

It is optionally possible to provide evaluation of partial derivatives for an FMU.
For Model Exchange, this means computing the partial derivatives at a particular time instant.
For Co-Simulation, this means to compute the partial derivatives at a particular communication point.
One function is provided to compute directional derivatives.
This function can be used to construct the desired partial derivative matrices.

[source, C]
----
fmi2Status fmi2GetDirectionalDerivative(fmi2Component c,
                      const fmi2ValueReference vUnknown_ref[], size_t nUnknown,
                      const fmi2ValueReference vKnown_ref[] , size_t nKnown,
                      const fmi2Real dvKnown[],
                            fmi2Real dvUnknown[])
----

[role=indented2]
This function computes the directional derivatives of an FMU.
An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns.
The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1).
In every Mode, the general form of the FMU equations are:

[latexmath]
++++
\mathbf{v}_{unknown} = \mathbf{h}(\mathbf{v}_{known}, \mathbf{v}_{rest}),
++++

where

* latexmath:[\color{blue}{\mathbf{v}_{unknown}}] is the vector of unknown Real variables computed in the actual Mode:

** _Initialization Mode_: The exposed unknowns listed under `<ModelStructure><InitialUnknowns>` that have type Real.

** _Continuous-Time Mode (ModelExchange)_: The continuous-time outputs and state derivatives
(= the variables listed under `<ModelStructure><Outputs>` with type Real and `variability = "continuous"` and
the variables listed as state derivatives under `<ModelStructure><Derivatives>`).

** _Event Mode (ModelExchange)_: The same variables as in the Continuous-Time Mode and additionally variables
under `<ModelStructure><Outputs>` with type Real and `variability = "discrete"`.

** _Step Mode (CoSimulation)_: The variables listed under `<ModelStructure><Outputs>` with type Real
and `variability = continuous` or `discrete`.
If `<ModelStructure><Derivatives>` is present, also the variables listed here as state derivatives.

* latexmath:[\color{blue}{\mathbf{v}_{known}}] is the vector of Real input variables of function *h*
that changes its value in the actual Mode.
Details are described in the description of element `dependencies` in section 2.2.8.
_[For example continuous-time inputs in Continuous-Time Mode.
If a variable with `causality = "independent"` is explicitly defined under `ScalarVariable`pass:[s],
a directional derivative with respect to this variable can be computed.
If such a variable is not defined,
the directional derivative with respect to the independent variable cannot be calculated]._

* latexmath:[\color{blue}{\mathbf{v}_{rest}}] is the set of input variables of function *h*
that either changes its value in the actual Mode but are non-Real variables,
or do not change their values in this Mode,
but change their values in other Modes _[for example, discrete-time inputs in Continuous-Time Mode]_.

If the capability attribute `providesDirectionalDerivative` is `true`,
`fmi2GetDirectionalDerivative` computes a linear combination of the partial derivatives of *h* with
respect to the selected input variables latexmath:[\color{blue}{\mathbf{v}_{known}}]:

[latexmath]
++++
\Delta \mathbf{v}_{unknown} = \frac{\delta \mathbf{h}}{\delta \mathbf{v}_{known}}\Delta \mathbf{v}_{known}
++++

Accordingly, it computes the directional derivative vector
latexmath:[\color{blue}{\Delta \mathbf{v}_{unknown}}] (`dvUnknown`) from the seed vector
latexmath:[\color{blue}{\Delta \mathbf{v}_{known}}] (`dvKnown`)

_[The variable relationships are different in different modes.
For example, during Continuous-Time Mode,
a continuous-time output y does not depend on discrete-time inputs (because they are held constant between events).
However, at Event Mode, y depends on discrete-time inputs.]_ +
_The function may compute the directional derivatives by numerical differentiation taking
into account the sparseness of the equation system, or (preferred) by analytic derivatives._

_Example:_ +
_Assume an FMU has the output equations_

[latexmath]
++++
\begin{bmatrix}
y_1
\\
y_2
\end{bmatrix}
=
\begin{bmatrix}
g_1(x, u_1, u_3, u_4)
\\
g_2(x, u_1)
\end{bmatrix}
++++

_and this FMU is connected, so that latexmath:[\color{blue}{y_1, u_1, u_3}] appear in an algebraic loop.
Then the nonlinear solver needs a Jacobian and this Jacobian can be computed (without numerical differentiation)
provided the partial derivative of latexmath:[\color{blue}{y_1}] with respect to
latexmath:[\color{blue}{u_1}] and latexmath:[\color{blue}{u_3}] is available.
Depending on the environment where the FMUs are connected, these derivatives can be provided_

(a) _with one wrapper function around function fmi2GetDirectionalDerivative to compute the directional
derivatives with respect to these two variables (in other words, latexmath:[\color{blue}{v_{unknown} = y_1}],
latexmath:[\color{blue}{v_{known} = \left \{ u_1, u_3 \right \}}]), and then the environment calls
this wrapper function with latexmath:[\color{blue}{\Delta v_{known} = \left \{ 1, 0 \right \}}]
to compute the partial derivative with respect to
latexmath:[\color{blue}{u_1}] and latexmath:[\color{blue}{\Delta v_{known} = \left \{ 0, 1 \right \}}]
to compute the partial derivative with respect to latexmath:[\color{blue}{u_3}], or_

(b) _with two direct function calls of fmi2GetDirectionalDerivative
(in other words, latexmath:[\color{blue}{v_{unknown} = y_1, v_{known} = u_1, \Delta v_{known} = 1}];
and latexmath:[\color{blue}{v_{unknown} = y_1, v_{known} = u_3, \Delta v_{known} = 1}])._

_Note that a direct implementation of this function with analytic derivatives:_

(a) _Provides the directional derivative for all input variables;
so in the above example: latexmath:[\color{blue}{\Delta y_1 = \frac{\delta g_1}{\delta x} \cdot \Delta x + \frac{\delta g_1}{\delta u_1} \cdot \Delta u_1 + \frac{\delta g_1}{\delta u_3} \cdot \Delta u_3 + \frac{\delta g_1}{\delta u_4} \cdot \Delta u_4}]_

(b) _Initializes all seed-values to zero;
so in the above example: latexmath:[\color{blue}{\Delta x = \Delta u_1 = \Delta u_3 = \Delta u_4 = 0}]_

(c) _Computes the directional derivative with the seed-values provided in the function arguments;
so in the above example: latexmath:[\color{blue}{\Delta v_{unknown} = \Delta y_1 (\Delta x = 0, \Delta u_1 = 1, \Delta u_3 = 1, \Delta u_4 = 0)}]]_

_[Note, function fmi2GetDirectionalDerivative can be utilized for the following purposes:_

- _Numerical integrators of stiff methods need matrix latexmath:[\color{blue}{\frac{\delta \mathbf{f}}{\delta \mathbf{x}}}]._

- _If the FMU is connected with other FMUs,
the partial derivatives of the state derivatives and outputs with respect to the continuous
states and the inputs are needed in order to compute the Jacobian for the system of the connected FMUs._

- _If the FMU shall be linearized, the same derivatives as in the previous item are needed._

- _If the FMU is used as the model for an extended Kalman filter,
latexmath:[\color{blue}{\frac{\delta \mathbf{f}}{\delta \mathbf{x}}}] and
latexmath:[\color{blue}{\frac{\delta \mathbf{g}}{\delta \mathbf{x}}}] are needed._

_If a dense matrix shall be computed,
the columns of the matrix can be easily constructed by successive calls of fmi2GetDirectionalDerivative.
For example, constructing the system Jacobian
latexmath:[\color{blue}{\mathbf{A} = \frac{\delta \mathbf{f}}{\delta \mathbf{x}}}]
as dense matrix can be performed in the following way (in pseudocode notation):_

[source, C]
----
m = M_fmi2Instantiate("m", ...)  // "m" is the instance name
                                 // "M_" is the MODEL_IDENTIFIER
// from XML file
nx     = ...   // number of states
x_ref [..] = ...   // vector of value references of cont.-time states
xd_ref[..] = ...   // vector of value references of state derivatives
dvKnown[1] = {1.0}; //seed vector for fmi2GetDirectionalDerivative
...
// If required at this step, compute the Jacobian as dense matrix
   // Set time, states and inputs
   M_fmi2SetTime(m, time)
   M_fmi2SetContinuousStates(m, x, nx)
   M_fmi2SetReal/Integer/Boolean/String(m, ...)
   // Construct the Jacobian elements J[:,:] columnwise
for i in 1:nx loop
  M_fmi2GetDirectionalDerivative(m, xd_ref, nx, x_ref[i], 1, dvKnown, ci);
  J[:,i] = ci;    // ci is an auxiliary vector of nx elements
                  // (it holds the i-th column of the Jacobian)
end for;
----

_If the sparsity of a matrix shall be taken into account,
then the matrix can be constructed in the following way:_

. _The incidence information of the matrix (whether an element is zero or not zero)
is extracted from the XML file from element <ModelStructure>._

. _A so-called graph coloring algorithm is employed to determine the columns
of the matrix that can be computed by one call of fmi2GetDirectionalDerivative.
Efficient graph coloring algorithms are freely available,
such as library ColPack (https://cscapes.cs.purdue.edu/coloringpage/) written in C/C++ (LGPL),
or the routines by Coleman, Garbow, Moré: "Software for estimating sparse Jacobian matrices",
ACM Transactions on Mathematical Software - TOMS ,
vol. 10, no. 3, pp. 346-347, 1984. See e.g. http://www.netlib.org/toms/618._

. _For the columns determined in (2), one call to fmi2DirectionalDerivative is made.
After each such call,
the elements of the resulting directional derivative vector are copied into
their correct locations of the partial derivative matrix._

_More details and implementational notes are available from (Akesson et.al. 2012).]_
